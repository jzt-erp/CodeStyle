### 1. 分清真分页和假分页

    大家都知道分页分为真分页和假分页，并且假分页是特别耗费性能的。我们在使用的过程中也是以真分页为主，但是在使用EF写分页语句的时候，稍有不慎，真分页便会成为假分页：

语句1：
```c#
    query.ToList().Skip((PageIndex - 1) * PageSize).Take(PageSize);
```
语句2：
```c#
query.Skip((PageIndex - 1) * PageSize).Take(PageSize).ToList();
```

    上面两句话乍一看差不多，并且都会实现我们分页的需求。但是这两句的执行过程，生成的sql语句大有不同。第一条语句的执行过程是：

    a.先把数据全部都查询出来，放到内存中 

    b.转换成List 

    c.从List中进行分页操作，查询出结果。 这其实是假分页的效果。

    而第二条语句就是真分页了，将参数传到数据库，生成分页sql语句，在数据库中查询出结果。

### 1. 按需加载
    其实EF并不存在按需加载的概念，在加载数据的时候并不是需要所有的属性值，可能只需要一个Id，Name值。所以我们可以对要查询的实体进行一下筛选，只加载自己需要的某些列，避免加载大量的垃圾数据。在这里按需加载的概念只是加载需要的列。针对只读状态；

### 3. 注意事务的简短性
    在使用事务时,我们尽量要把与事务无关的东西放到事务外执行，比如（查询语句或者其他事务外的语句），如果让一个事务的执行时间过长,很容易引起资源死锁的问题,当用压力测时,马上就出现资源被锁的错误

### 4. NoTracking的使用
    查询出来的实体,如果不需要删除和修改,请用NoTracking查询。

    有时我们的实体只需要显示，无需更新，所以为了提高性能，我们不需要实体被EF context追踪。此时可以使用NoTracking的查询来得到实体，这样实体的状态会是Detached状态。


### 5. 对于逻辑相对复杂的查询,要随时监控生成的Sql语句。

    毕竟EF生成的语句,往往比我们生成的语句更加复杂,这个时候我们就要考虑是否通过其他方式来提高性能。比如自己写原生的sql语句，有时候原生SQL语句是更好的选择。


### 6. 延迟加载（Lazy Loading） 预加载（Eager Loading） ---INCLUDING

### 7. EF的MAP配置  IsRequired  

### 8. 索引建立

### 9. EF拿数据的表达式书写不同拿的数据就不同

    StartsWith  Contains  indexof     
   

